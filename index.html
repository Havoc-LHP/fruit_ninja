<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ°´æœå¿è€… - æ‰‹åŠ¿æ§åˆ¶</title>
    <!-- å¼•å…¥ Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ä½¿ç”¨ Inter å­—ä½“ */
        :root {
            font-family: 'Inter', sans-serif;
        }

        /* ä¿è¯å®¹å™¨å®šä½å’Œå®½é«˜ - å°ºå¯¸å¢å¤§ */
        .game-container {
            display: flex;
            flex-direction: column;
            max-width: 1000px; /* å¢å¤§æœ€å¤§å®½åº¦ */
            width: 95%; /* é€‚åº”å¤§éƒ¨åˆ†å±å¹• */
            height: 90vh; /* å¢å¤§é«˜åº¦ */
            min-height: 500px;
            background: #2d3748; /* å®¹å™¨èƒŒæ™¯ */
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        
        .game-area {
            position: relative;
            flex-grow: 1;
        }

        #video, #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* åŸå§‹è§†é¢‘æºï¼Œä»…ç”¨äºæ¨¡å‹æ£€æµ‹ï¼Œä¿æŒéšè— */
        #video {
            position: absolute;
            top: 0;
            left: 0;
            visibility: hidden;
            z-index: -1; 
            transform: scaleX(-1); /* ä¿æŒé•œåƒï¼Œç¡®ä¿æ¨¡å‹åæ ‡æ­£ç¡® */
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10; 
            background: none; /* èƒŒæ™¯ç”± JS ç»˜åˆ¶ */
        }
        
        /* æµ®åŠ¨å…ƒç´  */
        .floating-ui {
            position: absolute;
            padding: 1rem;
            z-index: 20;
        }
        
        /* èŠ‚ç‚¹è¿½è¸ªç”»é¢ (å³ä¸Šè§’) */
        #tracker-canvas {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 150px; /* å°çª—å£å°ºå¯¸ */
            height: 112px; 
            border: 4px solid #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            z-index: 30; /* å¿…é¡»åœ¨æ‰€æœ‰UIå…ƒç´ ä¹‹ä¸Š */
            /* ä¿æŒé•œåƒï¼Œä»¥ä¾¿ç”¨æˆ·çœ‹åˆ°çš„æ‰‹éƒ¨ä¸è¿½è¸ªèŠ‚ç‚¹åŒ¹é… */
            transform: scaleX(-1); 
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 50;
        }
    </style>
    <!-- å¼•å…¥ TensorFlow.js å’Œ Hand Pose Detection åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915"></script>
</head>
<body class="bg-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="game-container">
        
        <div class="game-area">
            <!-- è§†é¢‘æº (éšè—) -->
            <video id="video" playsinline autoplay></video> 
            <!-- ä¸»æ¸¸æˆç”»å¸ƒ -->
            <canvas id="canvas"></canvas>
            <!-- èŠ‚ç‚¹è¿½è¸ªç”»å¸ƒ (å³ä¸Šè§’) -->
            <canvas id="tracker-canvas"></canvas>
            
            <!-- å·¦ä¸Šè§’: ç§¯åˆ†æ˜¾ç¤º -->
            <div class="floating-ui top-0 left-0">
                <div class="bg-yellow-400 text-gray-900 p-2 rounded-lg shadow-xl border-2 border-yellow-600">
                    <span class="text-lg font-bold">SCORE:</span>
                    <span id="score-display" class="text-3xl font-extrabold ml-2">0</span>
                </div>
            </div>
            
            <!-- å³ä¸Šè§’: è®¡æ—¶å™¨æ˜¾ç¤º -->
            <div class="floating-ui top-0 right-0">
                <div class="bg-red-600 text-white p-2 rounded-lg shadow-xl border-2 border-red-800">
                    <span class="text-lg font-bold">TIME:</span>
                    <span id="timer-display" class="text-3xl font-extrabold ml-2">00:00</span>
                </div>
            </div>

            <!-- å³ä¸Šè§’: å…¨å±æŒ‰é’® (ä½äºè¿½è¸ªç”»é¢ä¸‹æ–¹) -->
            <div class="floating-ui top-32 right-0"> 
                <button id="fullscreen-btn" class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-150 transform hover:scale-105">
                    å…¨å± 
                </button>
            </div>
            
             <!-- å·¦ä¸‹è§’: æ¸¸æˆå‚æ•°/è¯´æ˜ -->
            <div class="floating-ui bottom-0 left-0 md:w-1/3 w-2/3">
                <div id="settings-panel" class="p-3 bg-gray-700 bg-opacity-90 text-white rounded-lg shadow-lg">
                    <h3 class="text-sm font-bold mb-1 border-b border-gray-600">ğŸ•¹ï¸ æ¸¸æˆè¯´æ˜</h3>
                    <p id="system-message" class="text-xs text-gray-300">æ­£åœ¨åŠ è½½æ¨¡å‹...</p>
                    <p class="text-xs mt-1">ä½¿ç”¨**é£ŸæŒ‡æŒ‡å°–**ä½œä¸ºåˆ‡åˆ€ï¼Œåˆ‡æ°´æœå¾—åˆ†ï¼Œåˆ‡åˆ°**ğŸ’£ç‚¸å¼¹**æ¸¸æˆç»“æŸã€‚</p>
                </div>
            </div>

            <!-- åŠ è½½æŒ‡ç¤ºå™¨ -->
            <div id="loading" class="loading-overlay hidden">
                <div class="flex flex-col items-center">
                    <svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span class="mt-4 text-sm">æ­£åœ¨åŠ è½½æ‰‹åŠ¿æ¨¡å‹...</span>
                </div>
            </div>
            
            <!-- æ¸¸æˆå¼€å§‹/ç»“æŸ æ¨¡æ€æ¡† -->
            <div id="game-modal" class="loading-overlay" style="z-index: 60;">
                <div class="p-8 bg-gray-900 rounded-xl shadow-2xl text-center border-4 border-yellow-500">
                    <h2 id="modal-title" class="text-4xl font-extrabold text-yellow-400 mb-4">æ°´æœå¿è€…</h2>
                    <p id="modal-message" class="text-white mb-6 text-lg">é€‰æ‹©éš¾åº¦å¹¶å¼€å§‹æ¸¸æˆï¼</p>
                    
                    <div id="difficulty-selector" class="flex flex-col space-y-3 mb-6">
                        <button data-mode="Easy" class="mode-btn px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg transition duration-150 transform hover:scale-105">åˆçº§ (5:00)</button>
                        <button data-mode="Medium" class="mode-btn px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg transition duration-150 transform hover:scale-105">ä¸­çº§ (3:00)</button>
                        <button data-mode="Hard" class="mode-btn px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg transition duration-150 transform hover:scale-105">é«˜çº§ (1:00)</button>
                    </div>
                    
                    <button id="restart-game-btn" class="px-8 py-4 bg-yellow-500 text-gray-900 text-xl font-extrabold rounded-lg shadow-lg hover:bg-yellow-400 transition duration-150 transform hover:scale-105 hidden">
                        é‡æ–°å¼€å§‹
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables & Constants ---
        let detector;
        let animationFrameId = null;
        let isModelLoaded = false;
        
        // çº¹ç†å’Œ URL
        const TEXTURE_URL = 'https://i5.3conline.com/images/piclib/201109/16/batch/1/109535/1316136424109zt3mmbxflj.jpg';
        let woodTexture = new Image();
        let isTextureLoaded = false;
        
        // --- Difficulty Settings (in seconds) ---
        const DIFFICULTY_SETTINGS = {
            Easy: { time: 300, spawnInterval: 1800, maxSpawn: 2, bombChance: 0.05, heightBoost: 1.0 }, // 5 minutes
            Medium: { time: 180, spawnInterval: 1500, maxSpawn: 3, bombChance: 0.10, heightBoost: 1.2 }, // 3 minutes
            Hard: { time: 60, spawnInterval: 1200, maxSpawn: 4, bombChance: 0.15, heightBoost: 1.5 }, // 1 minute
        };

        // --- Game State Variables ---
        let currentMode = 'Easy';
        let score = 0;
        let fruits = [];
        let particles = []; 
        let lastSpawnTime = 0;
        const FRUIT_MAX_RADIUS = 35;
        const GRAVITY = 0.6;
        const FRUIT_SPAWN_HEIGHT_BASE = 40; // åˆå§‹Yé€Ÿåº¦çš„åˆ†æ¯ï¼Œæ•°å­—è¶Šå°ï¼ŒæŠ›å¾—è¶Šé«˜
        let lastRender = 0; 
        
        let isGameOver = true;
        let timeRemaining = DIFFICULTY_SETTINGS[currentMode].time; // in seconds
        let timerInterval = null; // for setInterval
        let timeSinceLastBomb = 0; // ç¡®ä¿ç‚¸å¼¹ä¸ä¼šè¿ç»­å‡ºç°
        const MIN_TIME_BETWEEN_BOMBS = 4000;


        // Hand/Finger State
        let fingerTip = { x: -1, y: -1, z: 0 }; // å½“å‰é£ŸæŒ‡æŒ‡å°– (Landmark 8) 
        let previousFingerTip = { x: -1, y: -1 }; // ä¸Šä¸€å¸§çš„æŒ‡å°–ä½ç½®ï¼Œç”¨äºç»˜åˆ¶åˆ‡å‰²è·¯å¾„

        // HTML Elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const trackerCanvas = document.getElementById('tracker-canvas');
        const trackerCtx = trackerCanvas.getContext('2d');
        
        const loadingDiv = document.getElementById('loading');
        const scoreDisplay = document.getElementById('score-display');
        const systemMessage = document.getElementById('system-message');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const timerDisplay = document.getElementById('timer-display');
        const gameModal = document.getElementById('game-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const difficultySelector = document.getElementById('difficulty-selector');
        const restartGameBtn = document.getElementById('restart-game-btn');


        // --- 1. Utility Functions ---

        /**
         * è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„ 2D è·ç¦»ã€‚
         */
        function calculateDistance(point1, point2) {
            if (!point1 || !point2) return Infinity;
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const seconds = (totalSeconds % 60).toString().padStart(2, '0');
            return `${minutes}:${seconds}`;
        }
        
        // Landmark connection definition (MediaPipe Hand Skeleton)
        const connections = [
            [0, 1], [1, 2], [2, 3], [3, 4],       // Thumb
            [0, 5], [5, 6], [6, 7], [7, 8],       // Index
            [5, 9], [9, 10], [10, 11], [11, 12],  // Middle
            [9, 13], [13, 14], [14, 15], [15, 16], // Ring
            [13, 17], [17, 18], [18, 19], [19, 20], // Pinky
            [0, 17]                               // Palm
        ];

        /**
         * ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹å’Œè¿æ¥çº¿åˆ°è¿½è¸ªç”»å¸ƒ
         */
        function drawKeypoints(landmarks, context) {
            // ç»˜åˆ¶è¿æ¥çº¿
            context.strokeStyle = '#38bdf8'; // Sky blue
            context.lineWidth = 3;
            context.lineCap = 'round';
            context.beginPath();
            
            connections.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                context.moveTo(startPoint.x, startPoint.y);
                context.lineTo(endPoint.x, endPoint.y);
            });
            context.stroke();

            // ç»˜åˆ¶å…³é”®ç‚¹
            landmarks.forEach((point, index) => {
                context.beginPath();
                // é£ŸæŒ‡æŒ‡å°– (Landmark 8) ç”¨çº¢è‰²çªå‡ºæ˜¾ç¤º
                if (index === 8) { 
                    context.fillStyle = 'red';
                    context.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                } else {
                    context.fillStyle = 'white';
                    context.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                }
                context.fill();
            });
        }
        

        // --- 2. Fruit Class (Handles Fruits and Bombs) ---

        class Fruit {
            constructor(canvasWidth, canvasHeight, isBomb = false, heightBoost = 1.0) {
                // éšæœºä»å±å¹•å·¦ä¾§æˆ–å³ä¾§ç”Ÿæˆ
                const startX = Math.random() > 0.5 ? Math.random() * canvasWidth * 0.1 : canvasWidth * 0.9 - Math.random() * canvasWidth * 0.1;
                this.x = startX;
                this.y = canvasHeight + 10; // ä»å±å¹•ä¸‹æ–¹å¼€å§‹
                
                if (isBomb) {
                    this.type = 'bomb';
                    this.scoreValue = 0; 
                    this.radius = 40;
                } else {
                    this.type = 'fruit';
                    this.fruitType = Math.floor(Math.random() * 4); // 0, 1, 2, 3 for fruit types
                    this.scoreValue = [10, 15, 20, 25][this.fruitType];
                    this.radius = 20 + Math.random() * FRUIT_MAX_RADIUS;
                }
                
                // èµ‹äºˆä¸€ä¸ªå‘ä¸Šçš„åˆå§‹æŠ›ç‰©çº¿é€Ÿåº¦ (å¢åŠ é«˜åº¦)
                const baseVelocity = canvasHeight / FRUIT_SPAWN_HEIGHT_BASE;
                this.velocityY = -(baseVelocity * heightBoost + Math.random() * 5); 
                this.velocityX = (canvasWidth / 2 - this.x) / 100; // ç¨å¾®å‘ä¸­å¿ƒåæ–œ
                this.gravity = GRAVITY;
                
                this.sliced = false;
                this.sliceAnimationTime = 0;
            }

            update() {
                if (this.sliced) {
                    // é£æº…åŠ¨ç”»
                    this.velocityY += this.gravity * 0.5;
                    this.sliceAnimationTime += 1;
                } else {
                    // æ­£å¸¸æŠ›ç‰©çº¿
                    this.velocityY += this.gravity;
                }
                
                // æ£€æŸ¥æ˜¯å¦åº”è¯¥ä»é¡¶éƒ¨åå¼¹ (æ–°å¢é€»è¾‘)
                if (this.y < this.radius * 2 && this.velocityY < 0) {
                    this.velocityY *= -0.7; // åè½¬æ–¹å‘å¹¶æŸå¤±éƒ¨åˆ†èƒ½é‡ (0.7)
                    this.velocityY += this.gravity; // ç«‹å³å†æ¬¡åº”ç”¨é‡åŠ›
                }
                
                this.y += this.velocityY;
                this.x += this.velocityX;
            }

            draw(ctx) {
                if (this.sliceAnimationTime > 30) return; // ç§»é™¤é£æº…åŠ¨ç”»ç»“æŸçš„æ°´æœ

                const fruitEmoji = ['ğŸ‰', 'ğŸ', 'ğŸ¥', 'ğŸ’'][this.fruitType];
                const emoji = this.type === 'bomb' ? 'ğŸ’£' : fruitEmoji;
                const fontSize = this.type === 'bomb' ? this.radius * 1.5 : this.radius * 2;
                
                // ä½¿ç”¨ Emoji ç»˜åˆ¶
                if (this.sliced) {
                    ctx.save();
                    ctx.font = `${this.radius}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // ç»˜åˆ¶ä¸¤åŠåˆ‡å¼€çš„æ•ˆæœ
                    ctx.globalAlpha = 1 - this.sliceAnimationTime / 30; // æ¸éš
                    ctx.fillText(emoji, this.x - 10, this.y); 
                    ctx.fillText(emoji, this.x + 10, this.y + 5); 
                    ctx.restore();
                } else {
                    // ç»˜åˆ¶æœªåˆ‡å‰²çš„ç‰©ä½“
                    ctx.font = `${fontSize}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(emoji, this.x, this.y);
                }
            }
        }
        
        // --- 3. Particle Class (ç”¨äºé£æº…ç‰¹æ•ˆ) ---

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 2;
                this.color = color;
                this.life = 60; // ç²’å­ç”Ÿå‘½å‘¨æœŸ (å¸§)
                this.vx = (Math.random() - 0.5) * 5; // éšæœºæ°´å¹³é€Ÿåº¦
                this.vy = (Math.random() - 1) * 5; // éšæœºå‘ä¸Šé€Ÿåº¦
                this.gravity = 0.2;
            }

            update() {
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / 60; // æ¸éš
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- 4. Game Control Functions ---

        /**
         * å€’è®¡æ—¶æ›´æ–°é€»è¾‘
         */
        function updateTimer() {
            timeRemaining--;
            timerDisplay.textContent = formatTime(timeRemaining);
            
            if (timeRemaining <= 0) {
                clearInterval(timerInterval);
                endGame(`ğŸ‰ æ—¶é—´åˆ°ï¼ä½ çš„æœ€ç»ˆå¾—åˆ†æ˜¯ ${score}`);
            }
        }
        
        /**
         * å¼€å§‹æ¸¸æˆ
         */
        function startGame(mode) {
            if (timerInterval) clearInterval(timerInterval);
            
            currentMode = mode;
            const settings = DIFFICULTY_SETTINGS[mode];
            timeRemaining = settings.time;
            score = 0;
            fruits = [];
            particles = [];
            isGameOver = false;
            lastSpawnTime = 0;
            timeSinceLastBomb = performance.now(); // é‡ç½®ç‚¸å¼¹è®¡æ—¶
            
            scoreDisplay.textContent = score;
            timerDisplay.textContent = formatTime(timeRemaining);
            gameModal.classList.add('hidden');
            
            // å¯åŠ¨å€’è®¡æ—¶
            timerInterval = setInterval(updateTimer, 1000);
            
            // ç¡®ä¿åŠ¨ç”»å¾ªç¯æ­£åœ¨è¿è¡Œ
            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            systemMessage.textContent = `ğŸš€ æ¨¡å¼: ${mode} | ç›®æ ‡: åšæŒåˆ°æ—¶é—´ç»“æŸ`;
        }
        
        /**
         * ç»“æŸæ¸¸æˆ
         */
        function endGame(message) {
            isGameOver = true;
            if (timerInterval) clearInterval(timerInterval);
            
            modalTitle.textContent = "æ¸¸æˆç»“æŸï¼";
            modalMessage.innerHTML = `${message} <br> æœ€ç»ˆå¾—åˆ†: <span class="text-yellow-400 text-3xl font-bold">${score}</span>`;
            difficultySelector.classList.add('hidden');
            restartGameBtn.classList.remove('hidden');
            
            gameModal.classList.remove('hidden');
        }

        /**
         * é‡æ–°å¼€å§‹æ¸¸æˆ (æ˜¾ç¤ºæ¨¡å¼é€‰æ‹©ç•Œé¢)
         */
        function restartGame() {
             // é‡ç½® UI åˆ°æ¨¡å¼é€‰æ‹©çŠ¶æ€
            modalTitle.textContent = "æ°´æœå¿è€…";
            modalMessage.textContent = "é€‰æ‹©éš¾åº¦å¹¶å¼€å§‹æ¸¸æˆï¼";
            difficultySelector.classList.remove('hidden');
            restartGameBtn.classList.add('hidden');
            
            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            gameModal.classList.remove('hidden');
        }

        // --- 5. Game Logic Functions ---

        /**
         * æ£€æŸ¥æ°´æœ/ç‚¸å¼¹æ˜¯å¦è¢«åˆ‡å‰²
         */
        function checkSlice(item) {
            // ç®€å•ç¢°æ’æ£€æµ‹ï¼šæŒ‡å°–æ˜¯å¦åœ¨ç‰©ä½“åŠå¾„å†…
            const distance = calculateDistance(fingerTip, item);
            if (distance < item.radius) {
                
                if (item.type === 'bomb') {
                    // ğŸ’£ ç‚¸å¼¹é€»è¾‘ï¼šæ¸¸æˆç»“æŸ
                    endGame("ğŸ’£ ç‚¸å¼¹çˆ†ç‚¸ï¼æ¸¸æˆç«‹å³ç»“æŸï¼");
                    item.sliced = true; 
                    // çº¢è‰²å’Œé»‘è‰²çˆ†ç‚¸ç²’å­ç‰¹æ•ˆ
                    for (let i = 0; i < 40; i++) {
                        particles.push(new Particle(item.x, item.y, Math.random() > 0.5 ? '#ff4d4d' : '#333333'));
                    }
                    return; // é˜»æ­¢åç»­æ°´æœåˆ‡ç‰‡é€»è¾‘
                }

                // SLICE! æ°´æœåˆ‡ç‰‡é€»è¾‘
                item.sliced = true;
                score += item.scoreValue;
                scoreDisplay.textContent = score;
                item.velocityY = -10; // ç»™äºˆä¸€ä¸ªå‘ä¸Šçš„å¼¹è·³æ•ˆæœ
                item.velocityX = (Math.random() - 0.5) * 5;
                
                // åˆ›å»ºæœæ±ç²’å­ç‰¹æ•ˆ
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(item.x, item.y, item.color));
                }
            }
        }
        
        /**
         * æ¸¸æˆçŠ¶æ€æ›´æ–°
         */
        function updateGame(delta) {
            if (isGameOver) return; // æ¸¸æˆç»“æŸæ—¶åœæ­¢æ›´æ–°

            const now = performance.now();
            const settings = DIFFICULTY_SETTINGS[currentMode];

            // 1. Spawning
            if (now - lastSpawnTime > settings.spawnInterval) {
                let isBomb = false;
                if (Math.random() < settings.bombChance && now - timeSinceLastBomb > MIN_TIME_BETWEEN_BOMBS) {
                    isBomb = true;
                    timeSinceLastBomb = now;
                }

                const spawnCount = 1 + Math.floor(Math.random() * settings.maxSpawn);
                
                // ç¡®ä¿è‡³å°‘æœ‰ä¸€ä¸ªç‰©ä½“ç”Ÿæˆ
                for(let i = 0; i < spawnCount; i++) {
                     // ä»…åœ¨ç¬¬ä¸€ä¸ªç‰©ä½“ä¸Šåº”ç”¨ç‚¸å¼¹æ ‡è®°
                     const isCurrentBomb = isBomb && i === 0;
                     fruits.push(new Fruit(canvas.width, canvas.height, isCurrentBomb, settings.heightBoost));
                }
                
                lastSpawnTime = now;
            }

            // 2. Item movement and slicing
            fruits.forEach(item => {
                if (!item.sliced) {
                    // ä»…å¯¹æœªåˆ‡å‰²çš„ç‰©ä½“è¿›è¡Œç¢°æ’æ£€æµ‹
                    checkSlice(item);
                }
                item.update();
            });
            
            // 3. Particle Update
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);
            
            // 4. Clean up off-screen items
            fruits = fruits.filter(item => {
                // å¦‚æœç‰©ä½“å·²åˆ‡ï¼Œå…è®¸å®ƒé£æº…ä¸€æ®µè·ç¦»
                if (item.sliced) return item.sliceAnimationTime <= 30;
                
                // å¦‚æœæœªåˆ‡çš„ç‰©ä½“æ‰åˆ°å±å¹•åº•éƒ¨ä¸‹æ–¹ï¼Œåˆ™ç§»é™¤ (å¦‚æœç‚¸å¼¹æœªåˆ‡æ‰è½ï¼Œä¸è§¦å‘Game Over)
                return item.y > -100; 
            });
        }
        
        /**
         * æ¸¸æˆç”»é¢ç»˜åˆ¶ (ä¸» Canvas)
         */
        function drawGame() {
            // 1. æ¸…é™¤ Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 2. ç»˜åˆ¶èƒŒæ™¯
            if (isTextureLoaded) {
                // ä½¿ç”¨åŠ è½½çš„å›¾ç‰‡ä½œä¸ºèƒŒæ™¯
                ctx.drawImage(woodTexture, 0, 0, canvas.width, canvas.height);
            } else {
                // ç»˜åˆ¶æœ¨çº¹èƒŒæ™¯ (æ¨¡æ‹Ÿ) - Fallback
                const woodGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                woodGradient.addColorStop(0, '#5D4037'); // æ·±æ£•è‰²
                woodGradient.addColorStop(1, '#8D6E63'); // æµ…æ£•è‰²
                ctx.fillStyle = woodGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height); 
            }

            // 3. ç»˜åˆ¶åœ°é¢/å‘å°„åŒº
            const groundHeight = 50;
            ctx.fillStyle = 'rgba(26, 32, 44, 0.7)'; // åŠé€æ˜æ·±è‰²åœ°é¢
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight); 

            // 4. ç»˜åˆ¶æ‰€æœ‰ç‰©ä½“
            fruits.forEach(item => item.draw(ctx));
            
            // 5. ç»˜åˆ¶ç²’å­ç‰¹æ•ˆ
            ctx.save();
            particles.forEach(p => p.draw(ctx));
            ctx.restore();


            // 6. ç»˜åˆ¶åˆ€è¿¹å’ŒæŒ‡å°– (Blade Trail and Tip)
            if (fingerTip.x !== -1 && !isGameOver) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter'; // ä½¿åˆ€è¿¹æ›´äº®
                
                // ç»˜åˆ¶åˆ€è¿¹ï¼ˆå‰ä¸€å¸§åˆ°å½“å‰å¸§çš„è·¯å¾„ï¼‰
                if (previousFingerTip.x !== -1 && calculateDistance(fingerTip, previousFingerTip) < 100) {
                    ctx.beginPath();
                    ctx.moveTo(previousFingerTip.x, previousFingerTip.y);
                    ctx.lineTo(fingerTip.x, fingerTip.y);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; 
                    ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 15;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶æŒ‡å°– (åˆ€å°– - ä½¿ç”¨ä¸‰è§’å½¢æ¨¡æ‹Ÿå°åˆ€)
                ctx.beginPath();
                ctx.moveTo(fingerTip.x, fingerTip.y - 12); // åˆ€å°–
                ctx.lineTo(fingerTip.x + 8, fingerTip.y + 8); // å³ä¾§åº•éƒ¨
                ctx.lineTo(fingerTip.x - 8, fingerTip.y + 8); // å·¦ä¾§åº•éƒ¨
                ctx.closePath();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 1)'; // äº®ç™½è‰²åˆ€èº«
                ctx.shadowColor = 'rgba(255, 255, 0, 1)'; // é»„è‰²å…‰æ™•
                ctx.shadowBlur = 15;
                ctx.fill();
                
                ctx.restore();
                
                // æ›´æ–°ä¸Šä¸€å¸§ä½ç½®
                previousFingerTip.x = fingerTip.x;
                previousFingerTip.y = fingerTip.y;
            } else {
                 // å¦‚æœæ‰‹ä¸è§äº†æˆ–æ¸¸æˆç»“æŸï¼Œé‡ç½®å‰ä¸€å¸§ä½ç½®
                 previousFingerTip.x = -1;
                 previousFingerTip.y = -1;
            }
        }

        /**
         * ç»˜åˆ¶è¿½è¸ªç”»é¢ (å³ä¸Šè§’ Tracker Canvas)
         */
        function drawTracker(hands) {
             // 1. ç»˜åˆ¶è§†é¢‘å¸§ (Tracker Canvas has CSS transform: scaleX(-1) applied)
            trackerCtx.clearRect(0, 0, trackerCanvas.width, trackerCanvas.height);
            
            // ç›´æ¥ç»˜åˆ¶è§†é¢‘å†…å®¹ã€‚
            trackerCtx.drawImage(
                video, 
                0, 0, video.videoWidth, video.videoHeight, // æºåŒºåŸŸ
                0, 0, trackerCanvas.width, trackerCanvas.height // ç›®æ ‡åŒºåŸŸ
            );
            
            // 2. ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹
            if (hands && hands.length > 0) {
                // ç¼©æ”¾/æ˜ å°„å…³é”®ç‚¹åˆ°å°ç”»å¸ƒçš„å°ºå¯¸
                const scaleX = trackerCanvas.width / video.videoWidth;
                const scaleY = trackerCanvas.height / video.videoHeight;
                
                // å¯¹ X åæ ‡è¿›è¡Œç¿»è½¬ï¼Œä»¥æŠµæ¶ˆ CSS transform: scaleX(-1) çš„æ•ˆæœ
                const scaledLandmarks = hands[0].keypoints.map(p => ({
                    x: (video.videoWidth - p.x) * scaleX, 
                    y: p.y * scaleY,
                    z: p.z 
                }));
                
                drawKeypoints(scaledLandmarks, trackerCtx);
            }
        }


        // --- 6. TensorFlow/MediaPipe Detection ---

        /**
         * å®æ—¶æ£€æµ‹æ‰‹éƒ¨ï¼Œå¹¶æ›´æ–°æŒ‡å°–ä½ç½®
         */
        async function detectHands() {
            if (!detector || video.paused || video.ended) {
                return;
            }

            // åœ¨ video å…ƒç´ ä¸Šè¿è¡Œæ£€æµ‹ï¼Œå¹¶ä¿æŒ flipHorizontal: true æ¥æ ¡æ­£åæ ‡
            const hands = await detector.estimateHands(video, {
                flipHorizontal: true
            });
            
            // ç»˜åˆ¶åˆ°è¿½è¸ªç”»å¸ƒ (æ— è®ºæ˜¯å¦æ£€æµ‹åˆ°æ‰‹)
            drawTracker(hands);

            if (hands && hands.length > 0) {
                // ä»…ä½¿ç”¨æ£€æµ‹åˆ°çš„ç¬¬ä¸€åªæ‰‹
                const landmarks = hands[0].keypoints;
                
                // é£ŸæŒ‡æŒ‡å°–æ˜¯å…³é”®ç‚¹ 8
                const indexTip = landmarks[8];
                
                // æ›´æ–°æŒ‡å°–å…¨å±€çŠ¶æ€
                fingerTip.x = indexTip.x;
                fingerTip.y = indexTip.y;
                fingerTip.z = indexTip.z;
                
                if (!isGameOver) {
                    systemMessage.textContent = `âœ… æ£€æµ‹ä¸­ï¼šä½¿ç”¨é£ŸæŒ‡æŒ‡å°– (X:${Math.round(indexTip.x)}, Y:${Math.round(indexTip.y)})`;
                }

            } else {
                // æ‰‹éƒ¨æœªæ£€æµ‹åˆ°ï¼Œé‡ç½®æŒ‡å°–ä½ç½®
                fingerTip.x = -1;
                fingerTip.y = -1;
                if (!isGameOver) {
                    systemMessage.textContent = 'ğŸ‘† è¯·ä¼¸å‡ºé£ŸæŒ‡ï¼Œæ”¾åœ¨é•œå¤´å‰ã€‚';
                }
            }
        }

        /**
         * åŠ è½½èƒŒæ™¯çº¹ç†
         */
        function loadTexture() {
            woodTexture.onload = () => {
                isTextureLoaded = true;
                console.log('Wood texture loaded successfully.');
            };
            woodTexture.onerror = () => {
                console.error('Failed to load wood texture. Using fallback.');
                // çº¹ç†åŠ è½½å¤±è´¥æ—¶ï¼Œä¿æŒ isTextureLoaded ä¸º falseï¼ŒdrawGame ä¼šä½¿ç”¨æ¸å˜å›é€€
                isTextureLoaded = false;
            };
            woodTexture.src = TEXTURE_URL;
        }

        // --- 7. Main Loop & Setup ---

        /**
         * æ¸¸æˆä¸»å¾ªç¯
         */
        function gameLoop(timestamp) {
            // 1. å¼‚æ­¥æ£€æµ‹æ‰‹éƒ¨ï¼ˆä¸ç­‰å¾…ç»“æœï¼Œéé˜»å¡ï¼‰
            detectHands(); 

            // 2. æ›´æ–°æ¸¸æˆçŠ¶æ€
            const delta = timestamp - lastRender;
            if (delta > 0 && delta < 200) { // é¿å…åˆå§‹æˆ–ä¸¢å¤±ç„¦ç‚¹æ—¶çš„å·¨å¤§æ—¶é—´å·®
                updateGame(delta);
            }
            lastRender = timestamp;

            // 3. ç»˜åˆ¶æ¸¸æˆç”»é¢
            drawGame();

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * åˆå§‹åŒ–æ‘„åƒå¤´å’Œ Canvas å°ºå¯¸
         */
        async function setupWebcam() {
            systemMessage.textContent = 'æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...';
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 'video': true });
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    video.play();
                    
                    // è®¾ç½® Canvas å†…éƒ¨ç»˜åˆ¶å°ºå¯¸ä¸è§†é¢‘æºåŒ¹é…ï¼ˆé‡è¦ï¼šæ¨¡å‹åæ ‡ä¾èµ–æ­¤å°ºå¯¸ï¼‰
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    // è¿½è¸ªç”»å¸ƒçš„å†…éƒ¨å°ºå¯¸ä¹Ÿéœ€è¦ä¸è§†é¢‘æºåŒ¹é…
                    trackerCanvas.width = video.videoWidth;
                    trackerCanvas.height = video.videoHeight;
                    
                    loadModel();
                };
            } catch (e) {
                systemMessage.textContent = 'âŒ æ— æ³•è®¿é—®æ‘„åƒå¤´ã€‚è¯·æ£€æŸ¥æƒé™ã€‚';
                console.error('Error accessing webcam:', e);
                loadingDiv.classList.add('hidden');
            }
        }

        /**
         * åŠ è½½ Hand Pose Detection æ¨¡å‹
         */
        async function loadModel() {
            systemMessage.textContent = 'æ­£åœ¨åŠ è½½æ‰‹éƒ¨æ¨¡å‹...';
            loadingDiv.classList.remove('hidden');

            try {
                const model = window.handPoseDetection.SupportedModels.MediaPipeHands;
                const detectorConfig = {
                    runtime: 'mediapipe', 
                    modelType: 'full', 
                    solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915' 
                };
                
                detector = await window.handPoseDetection.createDetector(model, detectorConfig);
                isModelLoaded = true;
                loadingDiv.classList.add('hidden');
                
                // æ¨¡å‹åŠ è½½å®Œæˆåï¼Œæ˜¾ç¤ºæ¸¸æˆæ¨¡å¼é€‰æ‹©ç•Œé¢
                restartGame(); 
                
                // å¯åŠ¨åŠ¨ç”»å¾ªç¯ï¼ˆå³ä½¿åœ¨Game OverçŠ¶æ€ï¼Œä¹Ÿéœ€è¦è¿è¡Œæ¥å¤„ç†UIå’Œæ£€æµ‹ï¼‰
                if (!animationFrameId) {
                    animationFrameId = requestAnimationFrame(gameLoop);
                }

            } catch (e) {
                console.error('Error loading model:', e);
                systemMessage.textContent = 'âŒ æ¨¡å‹åŠ è½½å¤±è´¥ã€‚è¯·æ£€æŸ¥ç½‘ç»œã€‚';
                loadingDiv.classList.add('hidden');
            }
        }
        
        // --- 8. Event Listeners ---

        // å…¨å±æŒ‰é’®äº‹ä»¶
        fullscreenBtn.addEventListener('click', () => {
            const gameContainer = document.querySelector('.game-container');
            if (document.fullscreenElement) {
                document.exitFullscreen();
                fullscreenBtn.textContent = 'å…¨å±';
            } else {
                if (gameContainer.requestFullscreen) {
                    gameContainer.requestFullscreen();
                    fullscreenBtn.textContent = 'é€€å‡ºå…¨å±';
                }
            }
        });

        // éš¾åº¦é€‰æ‹©æŒ‰é’®äº‹ä»¶
        difficultySelector.addEventListener('click', (event) => {
            if (event.target.classList.contains('mode-btn')) {
                const mode = event.target.dataset.mode;
                startGame(mode);
            }
        });

        // é‡æ–°å¼€å§‹æŒ‰é’®äº‹ä»¶
        restartGameBtn.addEventListener('click', restartGame);


        /**
         * å¯åŠ¨åº”ç”¨
         */
        window.onload = () => {
            if (typeof tf === 'undefined' || typeof window.handPoseDetection === 'undefined') {
                systemMessage.textContent = 'âŒ å…³é”®çš„æœºå™¨å­¦ä¹ åº“åŠ è½½å¤±è´¥ã€‚';
                loadingDiv.classList.add('hidden');
                return;
            }
            loadTexture(); // é¢„åŠ è½½èƒŒæ™¯çº¹ç†
            setupWebcam();
        };

        // åœæ­¢åŠ¨ç”»å¾ªç¯
        window.onbeforeunload = () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        };
        
        // åˆå§‹è®¾ç½®è®¡æ—¶å™¨æ˜¾ç¤º
        timerDisplay.textContent = formatTime(DIFFICULTY_SETTINGS['Easy'].time);

    </script>
</body>
</html>