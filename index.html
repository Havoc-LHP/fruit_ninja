<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ°´æœå¿è€… - æ‰‹åŠ¿æ§åˆ¶</title>
    <!-- å¼•å…¥ Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ä½¿ç”¨ Inter å­—ä½“ */
        :root {
            font-family: 'Inter', sans-serif;
        }

        /* ä¿è¯å®¹å™¨å®šä½å’Œå®½é«˜ - å“åº”å¼ä¼˜åŒ– */
        .game-container {
            display: flex;
            flex-direction: column;
            max-width: 1000px; 
            width: 95%; 
            height: 90vh; 
            min-height: 500px;
            background: #2d3748; /* å®¹å™¨èƒŒæ™¯ */
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            /* --- æ‰‹æœºç«¯é€‚é… --- */
            /* æ‰‹æœºä¸Šå æ»¡æ•´ä¸ªè§†å£ï¼Œå¹¶ç§»é™¤åœ†è§’ */
            transition: all 0.3s ease-in-out;
        }
        
        @media (max-width: 768px) {
            .game-container {
                max-width: 100vw;
                width: 100vw;
                height: 100vh;
                min-height: initial;
                border-radius: 0;
            }
        }
        
        .game-area {
            position: relative;
            flex-grow: 1;
        }

        #video, #canvas {
            display: block;
            width: 100%;
            height: 100%;
            /* ç¡®ä¿ canvas/video å°ºå¯¸é€‚åº”å®¹å™¨ï¼ŒåŒæ—¶ä¿æŒå†…éƒ¨å†…å®¹æ¯”ä¾‹ */
            object-fit: cover; 
        }

        /* åŸå§‹è§†é¢‘æºï¼Œä»…ç”¨äºæ¨¡å‹æ£€æµ‹ï¼Œä¿æŒéšè— */
        #video {
            position: absolute;
            top: 0;
            left: 0;
            visibility: hidden;
            z-index: -1; 
            transform: scaleX(-1); /* ä¿æŒé•œåƒï¼Œç¡®ä¿æ¨¡å‹åæ ‡æ­£ç¡® */
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10; 
            background: none; /* èƒŒæ™¯ç”± JS ç»˜åˆ¶ */
        }
        
        /* æµ®åŠ¨å…ƒç´  - è°ƒæ•´ padding é€‚åº”æ‰‹æœº */
        .floating-ui {
            position: absolute;
            padding: 1rem;
            z-index: 20;
        }
        @media (max-width: 768px) {
            .floating-ui {
                padding: 0.5rem; /* æ‰‹æœºä¸Šå‡å°å†…è¾¹è· */
            }
        }
        
        /* èŠ‚ç‚¹è¿½è¸ªç”»é¢ (å³ä¸Šè§’) */
        #tracker-canvas {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 150px; /* é»˜è®¤å°ºå¯¸ */
            height: 112px; 
            border: 4px solid #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            z-index: 30; 
            transform: scaleX(-1); 
        }
        /* æ‰‹æœºä¸Šç¼©å°è¿½è¸ªç”»é¢ */
        @media (max-width: 768px) {
            #tracker-canvas {
                width: 100px;
                height: 75px;
                top: 0.5rem;
                right: 0.5rem;
            }
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 50;
        }
    </style>
    <!-- å¼•å…¥ TensorFlow.js å’Œ Hand Pose Detection åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915"></script>
</head>
<body class="bg-gray-800 flex flex-col items-center justify-center min-h-screen p-0 md:p-4">

    <div class="game-container">
        
        <div class="game-area">
            <!-- è§†é¢‘æº (éšè—) -->
            <video id="video" playsinline autoplay></video> 
            <!-- ä¸»æ¸¸æˆç”»å¸ƒ -->
            <canvas id="canvas"></canvas>
            <!-- èŠ‚ç‚¹è¿½è¸ªç”»å¸ƒ (å³ä¸Šè§’) -->
            <canvas id="tracker-canvas"></canvas>
            
            <!-- å·¦ä¸Šè§’: ç§¯åˆ†æ˜¾ç¤º -->
            <div class="floating-ui top-0 left-0">
                <div class="bg-yellow-400 text-gray-900 p-2 rounded-lg shadow-xl border-2 border-yellow-600 md:text-base text-sm">
                    <span class="md:text-lg font-bold">SCORE:</span>
                    <span id="score-display" class="md:text-3xl text-xl font-extrabold ml-2">0</span>
                </div>
            </div>
            
            <!-- å³ä¸Šè§’: è®¡æ—¶å™¨æ˜¾ç¤º -->
            <div class="floating-ui top-0 right-0">
                <div class="bg-red-600 text-white p-2 rounded-lg shadow-xl border-2 border-red-800 md:text-base text-sm">
                    <span class="md:text-lg font-bold">TIME:</span>
                    <span id="timer-display" class="md:text-3xl text-xl font-extrabold ml-2">00:00</span>
                </div>
            </div>

            <!-- å³ä¸Šè§’: å…¨å±æŒ‰é’® (ä½äºè¿½è¸ªç”»é¢ä¸‹æ–¹) -->
            <div class="floating-ui top-32 right-0 md:top-32 top-24"> 
                <button id="fullscreen-btn" class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-150 transform hover:scale-105 text-sm md:text-base">
                    å…¨å± 
                </button>
            </div>
            
             <!-- å·¦ä¸‹è§’: æ¸¸æˆå‚æ•°/è¯´æ˜ -->
            <div class="floating-ui bottom-0 left-0 md:w-1/3 w-2/3">
                <div id="settings-panel" class="p-3 bg-gray-700 bg-opacity-90 text-white rounded-lg shadow-lg">
                    <h3 class="text-sm font-bold mb-1 border-b border-gray-600">ğŸ•¹ï¸ æ¸¸æˆè¯´æ˜</h3>
                    <p id="system-message" class="text-xs text-gray-300">æ­£åœ¨åŠ è½½æ¨¡å‹...</p>
                    <p class="text-xs mt-1">ä½¿ç”¨**é£ŸæŒ‡æŒ‡å°–**ä½œä¸ºåˆ‡åˆ€ï¼Œåˆ‡æ°´æœå¾—åˆ†ï¼Œåˆ‡åˆ°**ğŸ’£ç‚¸å¼¹**ä¼šæ‰£ 30 åˆ†ã€‚</p>
                </div>
            </div>

            <!-- åŠ è½½æŒ‡ç¤ºå™¨ -->
            <div id="loading" class="loading-overlay hidden">
                <div class="flex flex-col items-center">
                    <svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span class="mt-4 text-sm">æ­£åœ¨åŠ è½½æ‰‹åŠ¿æ¨¡å‹...</span>
                </div>
            </div>
            
            <!-- æ¸¸æˆå¼€å§‹/ç»“æŸ æ¨¡æ€æ¡† -->
            <div id="game-modal" class="loading-overlay" style="z-index: 60;">
                <div class="p-8 bg-gray-900 rounded-xl shadow-2xl text-center border-4 border-yellow-500 max-w-sm w-11/12">
                    <h2 id="modal-title" class="text-3xl md:text-4xl font-extrabold text-yellow-400 mb-4">æ°´æœå¿è€…</h2>
                    <p id="modal-message" class="text-white mb-6 text-base md:text-lg">é€‰æ‹©éš¾åº¦å¹¶å¼€å§‹æ¸¸æˆï¼</p>
                    
                    <div id="difficulty-selector" class="flex flex-col space-y-3 mb-6">
                        <button data-mode="Easy" class="mode-btn px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg transition duration-150 transform hover:scale-105">åˆçº§ (5:00)</button>
                        <button data-mode="Medium" class="mode-btn px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-lg transition duration-150 transform hover:scale-105">ä¸­çº§ (3:00)</button>
                        <button data-mode="Hard" class="mode-btn px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg transition duration-150 transform hover:scale-105">é«˜çº§ (1:00)</button>
                    </div>
                    
                    <button id="restart-game-btn" class="px-8 py-4 bg-yellow-500 text-gray-900 text-xl font-extrabold rounded-lg shadow-lg hover:bg-yellow-400 transition duration-150 transform hover:scale-105 hidden">
                        é‡æ–°å¼€å§‹
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables & Constants ---
        let detector;
        let animationFrameId = null;
        let isModelLoaded = false;
        
        // çº¹ç†å’Œ URL
        const TEXTURE_URL = 'https://i5.3conline.com/images/piclib/201109/16/batch/1/109535/1316136424109zt3mmbxflj.jpg';
        let woodTexture = new Image();
        let isTextureLoaded = false;
        
        // --- Difficulty Settings (in seconds) ---
        const DIFFICULTY_SETTINGS = {
            Easy: { time: 300, spawnInterval: 1800, maxSpawn: 2, bombChance: 0.05 }, // 5 minutes
            Medium: { time: 180, spawnInterval: 1500, maxSpawn: 3, bombChance: 0.10 }, // 3 minutes
            Hard: { time: 60, spawnInterval: 1200, maxSpawn: 4, bombChance: 0.15 }, // 1 minute
        };

        // --- Game State Variables ---
        let currentMode = 'Easy';
        let score = 0;
        let fruits = [];
        let particles = []; 
        let lastSpawnTime = 0;
        const FRUIT_MAX_RADIUS = 35;
        const GRAVITY = 0.6;
        let lastRender = 0; 
        
        let isGameOver = true;
        let timeRemaining = DIFFICULTY_SETTINGS[currentMode].time; // in seconds
        let timerInterval = null; // for setInterval
        let timeSinceLastBomb = 0; // ç¡®ä¿ç‚¸å¼¹ä¸ä¼šè¿ç»­å‡ºç°
        const MIN_TIME_BETWEEN_BOMBS = 4000;


        // Hand/Finger State
        let fingerTip = { x: -1, y: -1, z: 0 }; // å½“å‰é£ŸæŒ‡æŒ‡å°– (Landmark 8) 
        let previousFingerTip = { x: -1, y: -1 }; // ä¸Šä¸€å¸§çš„æŒ‡å°–ä½ç½®ï¼Œç”¨äºç»˜åˆ¶åˆ‡å‰²è·¯å¾„

        // HTML Elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const trackerCanvas = document.getElementById('tracker-canvas');
        const trackerCtx = trackerCanvas.getContext('2d');
        
        const loadingDiv = document.getElementById('loading');
        const scoreDisplay = document.getElementById('score-display');
        const systemMessage = document.getElementById('system-message');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const timerDisplay = document.getElementById('timer-display');
        const gameModal = document.getElementById('game-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const difficultySelector = document.getElementById('difficulty-selector');
        const restartGameBtn = document.getElementById('restart-game-btn');


        // --- 1. Utility Functions ---

        /**
         * è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„ 2D è·ç¦»ã€‚
         */
        function calculateDistance(point1, point2) {
            if (!point1 || !point2) return Infinity;
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const seconds = (totalSeconds % 60).toString().padStart(2, '0');
            return `${minutes}:${seconds}`;
        }
        
        // Landmark connection definition (MediaPipe Hand Skeleton)
        const connections = [
            [0, 1], [1, 2], [2, 3], [3, 4],       // Thumb
            [0, 5], [5, 6], [6, 7], [7, 8],       // Index
            [5, 9], [9, 10], [10, 11], [11, 12],  // Middle
            [9, 13], [13, 14], [14, 15], [15, 16], // Ring
            [13, 17], [17, 18], [18, 19], [19, 20], // Pinky
            [0, 17]                               // Palm
        ];

        /**
         * ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹å’Œè¿æ¥çº¿åˆ°è¿½è¸ªç”»å¸ƒ
         */
        function drawKeypoints(landmarks, context) {
            // ç»˜åˆ¶è¿æ¥çº¿
            context.strokeStyle = '#38bdf8'; // Sky blue
            context.lineWidth = 3;
            context.lineCap = 'round';
            context.beginPath();
            
            connections.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                context.moveTo(startPoint.x, startPoint.y);
                context.lineTo(endPoint.x, endPoint.y);
            });
            context.stroke();

            // ç»˜åˆ¶å…³é”®ç‚¹
            landmarks.forEach((point, index) => {
                context.beginPath();
                // é£ŸæŒ‡æŒ‡å°– (Landmark 8) ç”¨çº¢è‰²çªå‡ºæ˜¾ç¤º
                if (index === 8) { 
                    context.fillStyle = 'red';
                    context.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                } else {
                    context.fillStyle = 'white';
                    context.arc(point.x, point.y, 4, 0, 2 * Math.PI);
                }
                context.fill();
            });
        }
        
        /**
         * ä¸‰æ¬¡è´å¡å°”æ›²çº¿è®¡ç®—
         * B(t) = (1-t)^3 P0 + 3(1-t)^2 t P1 + 3(1-t) t^2 P2 + t^3 P3
         * @param {number} t - Normalized time (0 to 1)
         * @param {object} p0 - Start Point
         * @param {object} p1 - Control Point 1
         * @param {object} p2 - Control Point 2
         * @param {object} p3 - End Point
         */
        function getBezierPoint(t, p0, p1, p2, p3) {
            const t2 = t * t;
            const t3 = t2 * t;
            const mt = 1 - t;
            const mt2 = mt * mt;
            const mt3 = mt2 * mt;

            const x = mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x;
            const y = mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y;
            return { x, y };
        }

        // --- 2. Fruit Class (Handles Fruits and Bombs) ---

        class Fruit {
            constructor(canvasWidth, canvasHeight, isBomb = false) {
                
                // è´å¡å°”æ›²çº¿å‚æ•°
                this.pathDuration = 60 + Math.random() * 60; // 1 to 2 seconds at 60 FPS
                this.t = 0; // Current frame counter (0 to pathDuration)

                // éšæœºä»å±å¹•å·¦ä¾§æˆ–å³ä¾§ç”Ÿæˆ
                const startX = Math.random() * canvasWidth * 0.2 + (Math.random() < 0.5 ? 0 : canvasWidth * 0.8);
                const launchHeight = canvasHeight + 10; // ä»å±å¹•ä¸‹æ–¹å¼€å§‹
                const midX = canvasWidth / 2;
                
                // P0: èµ·å§‹ç‚¹ (å±å¹•åº•éƒ¨)
                this.p0 = { x: startX, y: launchHeight };
                
                // P3: ç»“æŸç‚¹ (å±å¹•åº•éƒ¨, å€¾å‘äºåœ¨å¯¹ä¾§è½ä¸‹)
                this.p3 = { 
                    x: (canvasWidth - startX) + (Math.random() - 0.5) * canvasWidth * 0.1, 
                    y: launchHeight 
                };

                // P1 & P2: æ§åˆ¶ç‚¹ (å®šä¹‰å¼§åº¦ï¼Œç”¨äºæ‹‰é«˜æ°´æœåˆ°å±å¹•é¡¶éƒ¨)
                const apexY = canvasHeight * (0.05 + Math.random() * 0.2); // é¡¶ç‚¹é«˜åº¦ (5% to 25% down)

                // P1: é è¿‘èµ·å§‹ç‚¹ 1/3 å¤„
                this.p1 = { 
                    x: startX + (this.p3.x - startX) * 0.3 + (Math.random() - 0.5) * 150,
                    y: apexY + Math.random() * 100 // ä½äºæˆ–æ¥è¿‘é¡¶ç‚¹é«˜åº¦
                };
                // P2: é è¿‘ç»“æŸç‚¹ 2/3 å¤„
                this.p2 = { 
                    x: startX + (this.p3.x - startX) * 0.7 + (Math.random() - 0.5) * 150,
                    y: apexY - Math.random() * 100 // ä½äºæˆ–æ¥è¿‘é¡¶ç‚¹é«˜åº¦
                };
                
                // ç¡®ä¿èµ·å§‹ç‚¹å’Œç»“æŸç‚¹åœ¨å±å¹•å†…
                this.p3.x = Math.max(0, Math.min(canvasWidth, this.p3.x));
                
                // åˆå§‹ä½ç½®
                this.x = this.p0.x;
                this.y = this.p0.y;

                if (isBomb) {
                    this.type = 'bomb';
                    this.scoreValue = 0; 
                    this.radius = 40;
                } else {
                    this.type = 'fruit';
                    this.fruitType = Math.floor(Math.random() * 4); // 0, 1, 2, 3 for fruit types
                    this.scoreValue = [10, 15, 20, 25][this.fruitType];
                    this.radius = 20 + Math.random() * FRUIT_MAX_RADIUS;
                }
                
                this.sliced = false;
                this.sliceAnimationTime = 0;
                
                // åˆ‡å‰²åä½¿ç”¨çš„ç‰©ç†å±æ€§
                this.velocityY = 0; 
                this.velocityX = 0;
                this.gravity = GRAVITY;
            }

            update() {
                if (this.sliced) {
                    // Sliced parts follow physics
                    this.velocityY += this.gravity * 0.5;
                    this.y += this.velocityY;
                    this.x += this.velocityX;
                    this.sliceAnimationTime += 1;
                } else {
                    // Uncut fruit follows BÃ©zier path
                    this.t += 1;
                    const tNormalized = this.t / this.pathDuration;

                    if (tNormalized >= 1) {
                        // Path finished, fruit should be removed in the main game loop
                        this.t = this.pathDuration + 1; 
                        return;
                    }

                    const newPos = getBezierPoint(tNormalized, this.p0, this.p1, this.p2, this.p3);
                    this.x = newPos.x;
                    this.y = newPos.y;
                }
            }

            draw(ctx) {
                if (this.sliceAnimationTime > 30) return; // ç§»é™¤é£æº…åŠ¨ç”»ç»“æŸçš„ç‰©ä½“

                const fruitEmoji = ['ğŸ‰', 'ğŸ', 'ğŸ¥', 'ğŸ’'][this.fruitType];
                const emoji = this.type === 'bomb' ? 'ğŸ’£' : fruitEmoji;
                const fontSize = this.type === 'bomb' ? this.radius * 1.5 : this.radius * 2;
                
                // ä½¿ç”¨ Emoji ç»˜åˆ¶
                if (this.sliced) {
                    ctx.save();
                    ctx.font = `${this.radius}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // ç»˜åˆ¶ä¸¤åŠåˆ‡å¼€çš„æ•ˆæœ
                    ctx.globalAlpha = 1 - this.sliceAnimationTime / 30; // æ¸éš
                    ctx.fillText(emoji, this.x - 10, this.y); 
                    ctx.fillText(emoji, this.x + 10, this.y + 5); 
                    ctx.restore();
                } else {
                    // ç»˜åˆ¶æœªåˆ‡å‰²çš„ç‰©ä½“
                    ctx.font = `${fontSize}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(emoji, this.x, this.y);
                }
            }
        }
        
        // --- 3. Particle Class (ç”¨äºé£æº…ç‰¹æ•ˆ) ---

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 2;
                this.color = color;
                this.life = 60; // ç²’å­ç”Ÿå‘½å‘¨æœŸ (å¸§)
                this.vx = (Math.random() - 0.5) * 5; // éšæœºæ°´å¹³é€Ÿåº¦
                this.vy = (Math.random() - 1) * 5; // éšæœºå‘ä¸Šé€Ÿåº¦
                this.gravity = 0.2;
            }

            update() {
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / 60; // æ¸éš
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- 4. Game Control Functions ---

        /**
         * å€’è®¡æ—¶æ›´æ–°é€»è¾‘
         */
        function updateTimer() {
            timeRemaining--;
            timerDisplay.textContent = formatTime(timeRemaining);
            
            if (timeRemaining <= 0) {
                clearInterval(timerInterval);
                endGame(`ğŸ‰ æ—¶é—´åˆ°ï¼ä½ çš„æœ€ç»ˆå¾—åˆ†æ˜¯ ${score}`);
            }
        }
        
        /**
         * å¼€å§‹æ¸¸æˆ
         */
        function startGame(mode) {
            if (timerInterval) clearInterval(timerInterval);
            
            currentMode = mode;
            const settings = DIFFICULTY_SETTINGS[mode];
            timeRemaining = settings.time;
            score = 0;
            fruits = [];
            particles = [];
            isGameOver = false;
            lastSpawnTime = 0;
            timeSinceLastBomb = performance.now(); // é‡ç½®ç‚¸å¼¹è®¡æ—¶
            
            scoreDisplay.textContent = score;
            timerDisplay.textContent = formatTime(timeRemaining);
            gameModal.classList.add('hidden');
            
            // å¯åŠ¨å€’è®¡æ—¶
            timerInterval = setInterval(updateTimer, 1000);
            
            // ç¡®ä¿åŠ¨ç”»å¾ªç¯æ­£åœ¨è¿è¡Œ
            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            systemMessage.textContent = `ğŸš€ æ¨¡å¼: ${mode} | ç›®æ ‡: åšæŒåˆ°æ—¶é—´ç»“æŸ`;
        }
        
        /**
         * ç»“æŸæ¸¸æˆ
         */
        function endGame(message) {
            isGameOver = true;
            if (timerInterval) clearInterval(timerInterval);
            
            modalTitle.textContent = "æ¸¸æˆç»“æŸï¼";
            modalMessage.innerHTML = `${message} <br> æœ€ç»ˆå¾—åˆ†: <span class="text-yellow-400 text-3xl font-bold">${score}</span>`;
            difficultySelector.classList.add('hidden');
            restartGameBtn.classList.remove('hidden');
            
            gameModal.classList.remove('hidden');
        }

        /**
         * é‡æ–°å¼€å§‹æ¸¸æˆ (æ˜¾ç¤ºæ¨¡å¼é€‰æ‹©ç•Œé¢)
         */
        function restartGame() {
             // é‡ç½® UI åˆ°æ¨¡å¼é€‰æ‹©çŠ¶æ€
            modalTitle.textContent = "æ°´æœå¿è€…";
            modalMessage.textContent = "é€‰æ‹©éš¾åº¦å¹¶å¼€å§‹æ¸¸æˆï¼";
            difficultySelector.classList.remove('hidden');
            restartGameBtn.classList.add('hidden');
            
            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            gameModal.classList.remove('hidden');
        }

        // --- 5. Game Logic Functions ---

        /**
         * æ£€æŸ¥æ°´æœ/ç‚¸å¼¹æ˜¯å¦è¢«åˆ‡å‰²
         */
        function checkSlice(item) {
            // ç®€å•ç¢°æ’æ£€æµ‹ï¼šæŒ‡å°–æ˜¯å¦åœ¨ç‰©ä½“åŠå¾„å†…
            const distance = calculateDistance(fingerTip, item);
            if (distance < item.radius) {
                
                if (item.type === 'bomb') {
                    // ç‚¸å¼¹é€»è¾‘ï¼šæ‰£åˆ†ï¼Œä½†ä¸ç»“æŸæ¸¸æˆ
                    score = Math.max(0, score - 30); // æ‰£ 30 åˆ†ï¼Œä½†å¾—åˆ†ä¸ä½äº 0
                    scoreDisplay.textContent = score;
                    item.sliced = true; 
                    
                    // ç»™äºˆè§†è§‰æç¤º
                    systemMessage.textContent = 'ğŸ’¥ è­¦å‘Šï¼šåˆ‡åˆ°ç‚¸å¼¹ï¼æ‰£é™¤ 30 åˆ†ã€‚';
                    setTimeout(() => {
                        if (!isGameOver) {
                            const mode = DIFFICULTY_SETTINGS[currentMode];
                            systemMessage.textContent = `ğŸš€ æ¨¡å¼: ${currentMode} | ç›®æ ‡: åšæŒåˆ°æ—¶é—´ç»“æŸ`;
                        }
                    }, 1500);

                    // çº¢è‰²å’Œé»‘è‰²çˆ†ç‚¸ç²’å­ç‰¹æ•ˆ
                    for (let i = 0; i < 40; i++) {
                        particles.push(new Particle(item.x, item.y, Math.random() > 0.5 ? '#ff4d4d' : '#333333'));
                    }
                    
                    // æ¨¡æ‹Ÿåˆ‡å‰²åçš„åˆ†æ•£
                    item.velocityY = -10; 
                    item.velocityX = (Math.random() - 0.5) * 5;
                    return; 
                }

                // SLICE! æ°´æœåˆ‡ç‰‡é€»è¾‘
                item.sliced = true;
                score += item.scoreValue;
                scoreDisplay.textContent = score;
                
                // æ¨¡æ‹Ÿåˆ‡å‰²åçš„åˆ†æ•£
                item.velocityY = -10; // ç»™äºˆä¸€ä¸ªå‘ä¸Šçš„å¼¹è·³æ•ˆæœ
                item.velocityX = (Math.random() - 0.5) * 5;
                
                // éšæœºé€‰æ‹©ç²’å­é¢œè‰² (æ¨¡æ‹Ÿæœæ±)
                const fruitColors = ['#ff6347', '#ffd700', '#00ff7f', '#dc143c']; 
                const color = fruitColors[item.fruitType % fruitColors.length];

                // åˆ›å»ºæœæ±ç²’å­ç‰¹æ•ˆ
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(item.x, item.y, color));
                }
            }
        }
        
        /**
         * æ¸¸æˆçŠ¶æ€æ›´æ–°
         */
        function updateGame(delta) {
            if (isGameOver) return; // æ¸¸æˆç»“æŸæ—¶åœæ­¢æ›´æ–°

            const now = performance.now();
            const settings = DIFFICULTY_SETTINGS[currentMode];

            // 1. Spawning
            if (now - lastSpawnTime > settings.spawnInterval) {
                let isBomb = false;
                if (Math.random() < settings.bombChance && now - timeSinceLastBomb > MIN_TIME_BETWEEN_BOMBS) {
                    isBomb = true;
                    timeSinceLastBomb = now;
                }

                const spawnCount = 1 + Math.floor(Math.random() * settings.maxSpawn);
                
                // ç¡®ä¿è‡³å°‘æœ‰ä¸€ä¸ªç‰©ä½“ç”Ÿæˆ
                for(let i = 0; i < spawnCount; i++) {
                     // ä»…åœ¨ç¬¬ä¸€ä¸ªç‰©ä½“ä¸Šåº”ç”¨ç‚¸å¼¹æ ‡è®°
                     const isCurrentBomb = isBomb && i === 0;
                     fruits.push(new Fruit(canvas.width, canvas.height, isCurrentBomb));
                }
                
                lastSpawnTime = now;
            }

            // 2. Item movement and slicing
            fruits.forEach(item => {
                if (!item.sliced) {
                    // ä»…å¯¹æœªåˆ‡å‰²çš„ç‰©ä½“è¿›è¡Œç¢°æ’æ£€æµ‹
                    checkSlice(item);
                }
                item.update();
            });
            
            // 3. Particle Update
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);
            
            // 4. Clean up off-screen items
            fruits = fruits.filter(item => {
                // å¦‚æœç‰©ä½“å·²åˆ‡ï¼Œå…è®¸å®ƒé£æº…ä¸€æ®µæ—¶é—´
                if (item.sliced) return item.sliceAnimationTime <= 30;
                
                // å¦‚æœæœªåˆ‡çš„ç‰©ä½“å·²å®Œæˆè´å¡å°”æ›²çº¿è·¯å¾„ (t > pathDuration)ï¼Œåˆ™ç§»é™¤
                return item.t <= item.pathDuration; 
            });
        }
        
        /**
         * æ¸¸æˆç”»é¢ç»˜åˆ¶ (ä¸» Canvas)
         */
        function drawGame() {
            // 1. æ¸…é™¤ Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 2. ç»˜åˆ¶èƒŒæ™¯ (å®ç° 'cover' / é•¿è¾¹è£åˆ‡)
            if (isTextureLoaded) {
                const imgRatio = woodTexture.naturalWidth / woodTexture.naturalHeight;
                const canvasRatio = canvas.width / canvas.height;
                let sx, sy, sw, sh; // Source (Image) coordinates
                
                if (imgRatio > canvasRatio) {
                    // å›¾åƒæ¯”ç”»å¸ƒå®½ (å›¾åƒæ¨ªå‘è£åˆ‡)
                    sh = woodTexture.naturalHeight;
                    sw = sh * canvasRatio;
                    sx = (woodTexture.naturalWidth - sw) / 2;
                    sy = 0;
                } else {
                    // å›¾åƒæ¯”ç”»å¸ƒé«˜ (å›¾åƒçºµå‘è£åˆ‡)
                    sw = woodTexture.naturalWidth;
                    sh = sw / canvasRatio;
                    sx = 0;
                    sy = (woodTexture.naturalHeight - sh) / 2;
                }
                
                // å°†è£åˆ‡åçš„éƒ¨åˆ†ç»˜åˆ¶åˆ°æ•´ä¸ª Canvas åŒºåŸŸ
                ctx.drawImage(woodTexture, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);
            } else {
                // ç»˜åˆ¶æœ¨çº¹èƒŒæ™¯ (æ¨¡æ‹Ÿ) - Fallback
                const woodGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                woodGradient.addColorStop(0, '#5D4037'); // æ·±æ£•è‰²
                woodGradient.addColorStop(1, '#8D6E63'); // æµ…æ£•è‰²
                ctx.fillStyle = woodGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height); 
            }

            // 3. ç»˜åˆ¶åœ°é¢/å‘å°„åŒº
            const groundHeight = 50;
            ctx.fillStyle = 'rgba(26, 32, 44, 0.7)'; // åŠé€æ˜æ·±è‰²åœ°é¢
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight); 

            // 4. ç»˜åˆ¶æ‰€æœ‰ç‰©ä½“
            fruits.forEach(item => item.draw(ctx));
            
            // 5. ç»˜åˆ¶ç²’å­ç‰¹æ•ˆ
            ctx.save();
            particles.forEach(p => p.draw(ctx));
            ctx.restore();


            // 6. ç»˜åˆ¶åˆ€è¿¹å’ŒæŒ‡å°– (Blade Trail and Tip)
            if (fingerTip.x !== -1 && !isGameOver) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter'; // ä½¿åˆ€è¿¹æ›´äº®
                
                // ç»˜åˆ¶åˆ€è¿¹ï¼ˆå‰ä¸€å¸§åˆ°å½“å‰å¸§çš„è·¯å¾„ï¼‰
                if (previousFingerTip.x !== -1 && calculateDistance(fingerTip, previousFingerTip) < 100) {
                    ctx.beginPath();
                    ctx.moveTo(previousFingerTip.x, previousFingerTip.y);
                    ctx.lineTo(fingerTip.x, fingerTip.y);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; 
                    ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 15;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶æŒ‡å°– (åˆ€å°– - ä½¿ç”¨ä¸‰è§’å½¢æ¨¡æ‹Ÿå°åˆ€)
                ctx.beginPath();
                ctx.moveTo(fingerTip.x, fingerTip.y - 12); // åˆ€å°–
                ctx.lineTo(fingerTip.x + 8, fingerTip.y + 8); // å³ä¾§åº•éƒ¨
                ctx.lineTo(fingerTip.x - 8, fingerTip.y + 8); // å·¦ä¾§åº•éƒ¨
                ctx.closePath();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 1)'; // äº®ç™½è‰²åˆ€èº«
                ctx.shadowColor = 'rgba(255, 255, 0, 1)'; // é»„è‰²å…‰æ™•
                ctx.shadowBlur = 15;
                ctx.fill();
                
                ctx.restore();
                
                // æ›´æ–°ä¸Šä¸€å¸§ä½ç½®
                previousFingerTip.x = fingerTip.x;
                previousFingerTip.y = fingerTip.y;
            } else {
                 // å¦‚æœæ‰‹ä¸è§äº†æˆ–æ¸¸æˆç»“æŸï¼Œé‡ç½®å‰ä¸€å¸§ä½ç½®
                 previousFingerTip.x = -1;
                 previousFingerTip.y = -1;
            }
        }

        /**
         * ç»˜åˆ¶è¿½è¸ªç”»é¢ (å³ä¸Šè§’ Tracker Canvas)
         */
        function drawTracker(hands) {
             // 1. ç»˜åˆ¶è§†é¢‘å¸§ (Tracker Canvas has CSS transform: scaleX(-1) applied)
            trackerCtx.clearRect(0, 0, trackerCanvas.width, trackerCanvas.height);
            
            // ç›´æ¥ç»˜åˆ¶è§†é¢‘å†…å®¹ã€‚
            trackerCtx.drawImage(
                video, 
                0, 0, video.videoWidth, video.videoHeight, // æºåŒºåŸŸ
                0, 0, trackerCanvas.width, trackerCanvas.height // ç›®æ ‡åŒºåŸŸ
            );
            
            // 2. ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹
            if (hands && hands.length > 0) {
                // ç¼©æ”¾/æ˜ å°„å…³é”®ç‚¹åˆ°å°ç”»å¸ƒçš„å°ºå¯¸
                const scaleX = trackerCanvas.width / video.videoWidth;
                const scaleY = trackerCanvas.height / video.videoHeight;
                
                // å¯¹ X åæ ‡è¿›è¡Œç¿»è½¬ï¼Œä»¥æŠµæ¶ˆ CSS transform: scaleX(-1) çš„æ•ˆæœ
                const scaledLandmarks = hands[0].keypoints.map(p => ({
                    x: (video.videoWidth - p.x) * scaleX, 
                    y: p.y * scaleY,
                    z: p.z 
                }));
                
                drawKeypoints(scaledLandmarks, trackerCtx);
            }
        }


        // --- 6. TensorFlow/MediaPipe Detection ---

        /**
         * å®æ—¶æ£€æµ‹æ‰‹éƒ¨ï¼Œå¹¶æ›´æ–°æŒ‡å°–ä½ç½®
         */
        async function detectHands() {
            if (!detector || video.paused || video.ended) {
                return;
            }

            // åœ¨ video å…ƒç´ ä¸Šè¿è¡Œæ£€æµ‹ï¼Œå¹¶ä¿æŒ flipHorizontal: true æ¥æ ¡æ­£åæ ‡
            const hands = await detector.estimateHands(video, {
                flipHorizontal: true
            });
            
            // ç»˜åˆ¶åˆ°è¿½è¸ªç”»å¸ƒ (æ— è®ºæ˜¯å¦æ£€æµ‹åˆ°æ‰‹)
            drawTracker(hands);

            if (hands && hands.length > 0) {
                // ä»…ä½¿ç”¨æ£€æµ‹åˆ°çš„ç¬¬ä¸€åªæ‰‹
                const landmarks = hands[0].keypoints;
                
                // é£ŸæŒ‡æŒ‡å°–æ˜¯å…³é”®ç‚¹ 8
                const indexTip = landmarks[8];
                
                // æ›´æ–°æŒ‡å°–å…¨å±€çŠ¶æ€
                fingerTip.x = indexTip.x;
                fingerTip.y = indexTip.y;
                fingerTip.z = indexTip.z;
                
                if (!isGameOver) {
                    systemMessage.textContent = `âœ… æ£€æµ‹ä¸­ï¼šä½¿ç”¨é£ŸæŒ‡æŒ‡å°– (X:${Math.round(indexTip.x)}, Y:${Math.round(indexTip.y)})`;
                }

            } else {
                // æ‰‹éƒ¨æœªæ£€æµ‹åˆ°ï¼Œé‡ç½®æŒ‡å°–ä½ç½®
                fingerTip.x = -1;
                fingerTip.y = -1;
                if (!isGameOver) {
                    systemMessage.textContent = 'ğŸ‘† è¯·ä¼¸å‡ºé£ŸæŒ‡ï¼Œæ”¾åœ¨é•œå¤´å‰ã€‚';
                }
            }
        }

        /**
         * è°ƒæ•´ Canvas å°ºå¯¸ä»¥é€‚åº”å®¹å™¨
         */
        function resizeCanvas() {
            const container = document.querySelector('.game-area');
            const containerRect = container.getBoundingClientRect();
            
            // æ³¨æ„: canvas.width/height å¿…é¡»æ˜¯è§†é¢‘çš„åŸå§‹åˆ†è¾¨ç‡ï¼Œä»¥ä¿æŒæ¨¡å‹åæ ‡å‡†ç¡®
            // æˆ‘ä»¬åªéœ€è¦ç¡®ä¿ CSS/display å°ºå¯¸ä¸å®¹å™¨åŒ¹é…å³å¯ï¼Œè¿™å·²ç”± CSS `width: 100%; height: 100%;` å¤„ç†
            
            // å¼ºåˆ¶é‡ç»˜ï¼Œç¡®ä¿èƒŒæ™¯å’Œå…ƒç´ åœ¨çª—å£å¤§å°å˜åŒ–åæ­£ç¡®æ˜¾ç¤º
            drawGame();
        }

        /**
         * åŠ è½½èƒŒæ™¯çº¹ç†
         */
        function loadTexture() {
            woodTexture.onload = () => {
                isTextureLoaded = true;
                console.log('Wood texture loaded successfully.');
            };
            woodTexture.onerror = () => {
                console.error('Failed to load wood texture. Using fallback.');
                // çº¹ç†åŠ è½½å¤±è´¥æ—¶ï¼Œä¿æŒ isTextureLoaded ä¸º falseï¼ŒdrawGame ä¼šä½¿ç”¨æ¸å˜å›é€€
                isTextureLoaded = false;
            };
            woodTexture.src = TEXTURE_URL;
        }

        // --- 7. Main Loop & Setup ---

        /**
         * æ¸¸æˆä¸»å¾ªç¯
         */
        function gameLoop(timestamp) {
            // 1. å¼‚æ­¥æ£€æµ‹æ‰‹éƒ¨ï¼ˆä¸ç­‰å¾…ç»“æœï¼Œéé˜»å¡ï¼‰
            detectHands(); 

            // 2. æ›´æ–°æ¸¸æˆçŠ¶æ€
            const delta = timestamp - lastRender;
            if (delta > 0 && delta < 200) { // é¿å…åˆå§‹æˆ–ä¸¢å¤±ç„¦ç‚¹æ—¶çš„å·¨å¤§æ—¶é—´å·®
                updateGame(delta);
            }
            lastRender = timestamp;

            // 3. ç»˜åˆ¶æ¸¸æˆç”»é¢
            drawGame();

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * åˆå§‹åŒ–æ‘„åƒå¤´å’Œ Canvas å°ºå¯¸
         */
        async function setupWebcam() {
            systemMessage.textContent = 'æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...';
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 'video': true });
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    video.play();
                    
                    // IMPORTANT: è®¾ç½® Canvas å†…éƒ¨ç»˜åˆ¶å°ºå¯¸ä¸è§†é¢‘æºåŒ¹é…ï¼ˆæ¨¡å‹åæ ‡ä¾èµ–æ­¤å°ºå¯¸ï¼‰
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    trackerCanvas.width = video.videoWidth;
                    trackerCanvas.height = video.videoHeight;
                    
                    // ç›‘å¬çª—å£å¤§å°å˜åŒ–
                    window.addEventListener('resize', resizeCanvas);
                    resizeCanvas(); // åˆå§‹è°ƒç”¨ä¸€æ¬¡
                    
                    loadModel();
                };
            } catch (e) {
                systemMessage.textContent = 'âŒ æ— æ³•è®¿é—®æ‘„åƒå¤´ã€‚è¯·æ£€æŸ¥æƒé™ã€‚';
                console.error('Error accessing webcam:', e);
                loadingDiv.classList.add('hidden');
            }
        }

        /**
         * åŠ è½½ Hand Pose Detection æ¨¡å‹
         */
        async function loadModel() {
            systemMessage.textContent = 'æ­£åœ¨åŠ è½½æ‰‹éƒ¨æ¨¡å‹...';
            loadingDiv.classList.remove('hidden');

            try {
                const model = window.handPoseDetection.SupportedModels.MediaPipeHands;
                const detectorConfig = {
                    runtime: 'mediapipe', 
                    modelType: 'full', 
                    solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915' 
                };
                
                detector = await window.handPoseDetection.createDetector(model, detectorConfig);
                isModelLoaded = true;
                loadingDiv.classList.add('hidden');
                
                // æ¨¡å‹åŠ è½½å®Œæˆåï¼Œæ˜¾ç¤ºæ¸¸æˆæ¨¡å¼é€‰æ‹©ç•Œé¢
                restartGame(); 
                
                // å¯åŠ¨åŠ¨ç”»å¾ªç¯ï¼ˆå³ä½¿åœ¨Game OverçŠ¶æ€ï¼Œä¹Ÿéœ€è¦è¿è¡Œæ¥å¤„ç†UIå’Œæ£€æµ‹ï¼‰
                if (!animationFrameId) {
                    animationFrameId = requestAnimationFrame(gameLoop);
                }

            } catch (e) {
                console.error('Error loading model:', e);
                systemMessage.textContent = 'âŒ æ¨¡å‹åŠ è½½å¤±è´¥ã€‚è¯·æ£€æŸ¥ç½‘ç»œã€‚';
                loadingDiv.classList.add('hidden');
            }
        }
        
        // --- 8. Event Listeners ---

        // å…¨å±æŒ‰é’®äº‹ä»¶
        fullscreenBtn.addEventListener('click', () => {
            const gameContainer = document.querySelector('.game-container');
            if (document.fullscreenElement) {
                document.exitFullscreen();
                fullscreenBtn.textContent = 'å…¨å±';
            } else {
                if (gameContainer.requestFullscreen) {
                    gameContainer.requestFullscreen();
                    fullscreenBtn.textContent = 'é€€å‡ºå…¨å±';
                }
            }
        });

        // éš¾åº¦é€‰æ‹©æŒ‰é’®äº‹ä»¶
        difficultySelector.addEventListener('click', (event) => {
            if (event.target.classList.contains('mode-btn')) {
                const mode = event.target.dataset.mode;
                startGame(mode);
            }
        });

        // é‡æ–°å¼€å§‹æŒ‰é’®äº‹ä»¶
        restartGameBtn.addEventListener('click', restartGame);


        /**
         * å¯åŠ¨åº”ç”¨
         */
        window.onload = () => {
            if (typeof tf === 'undefined' || typeof window.handPoseDetection === 'undefined') {
                systemMessage.textContent = 'âŒ å…³é”®çš„æœºå™¨å­¦ä¹ åº“åŠ è½½å¤±è´¥ã€‚';
                loadingDiv.classList.add('hidden');
                return;
            }
            loadTexture(); // é¢„åŠ è½½èƒŒæ™¯çº¹ç†
            setupWebcam();
        };

        // åœæ­¢åŠ¨ç”»å¾ªç¯
        window.onbeforeunload = () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            window.removeEventListener('resize', resizeCanvas);
            if (timerInterval) clearInterval(timerInterval);
        };
        
        // åˆå§‹è®¾ç½®è®¡æ—¶å™¨æ˜¾ç¤º
        timerDisplay.textContent = formatTime(DIFFICULTY_SETTINGS['Easy'].time);

    </script>
</body>
</html>
